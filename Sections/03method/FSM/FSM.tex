\subsection{Method for FSM}
Designing our FSM, we followed step by inspired inspired from, ref[youtube vidoen av FSM]:
\begin{enumerate}
    \item Define the purpose of the machine
    \item Draw a state diagram
    \item Make a state table
    \item Select type of flip-flop
    \item Find the boolean func. for each flip-flop
    \item Draw a logic circuit
\end{enumerate}
For \textbf{defining the purpose of the purpose} we have to use the criteria for the project, at the same time understand our MAC, what kind of inputs is necessesary for it work as it suposed i henhold to the project. The projects criteria where:
\begin{enumerate}
    \item The FSM has three inputs($CLK$, $RESET$, $RUN$). Reset: The reset signal, which is 1 when the circuit should reset and 0 otherwise. Clk: A clock signal which is 0 for half a period and then 1 for half a period. A signal that is 1 if your MAC unit should multiply and accumulate the answer,
    and 0 if you should pause the accumulation (and continue when Run is 1 again).
    \item multiply accumulate operation should be performed three (3) times in a row,
    followed by a pause for one clock cycle
    \item This 3+1 pattern should be repeated continously unless something else is indicated
    \begin{enumerate}
        \item If Run=0, no MAC operation should be run. When Run=1 again the
        MAC operation pattern should continue from where it left off (so if two operations are done and
        then Run=0, the third operation should be performed when Run=1 again followed by a pause-cycle
        before repeating the 3+1 pattern)
        \item If Reset=1 the MAC-pattern (3+1) should be reset so that
        whenever Reset goes low again we start with 3 operations followed by a pause regardless of where
        in the pattern we were before Reset was set high.
    \end{enumerate}
    \item The FSMâ€™s state should only be updated at the positive edge of the clock Clk
\end{enumerate}
Our MAC only gets updated when our CLK-input to our 8-bit register has a risising edge. The further plan to give us a signal 1 when the pause state occur.

For this we designed a \textbf{Statediagram} as shown in figure ... 

The \textbf{State table}, table \ref{State Table FSM}, is based on the statediagram: $P_{0}$, $P_{1}$ are \emph{Present state 0} and \emph{Present state 1},  with corresponding $N_{0}$, $N_{1}$ are \emph{Next State 0} and \emph{Next State 1}. Inputs are $RESET$ and $RUN$ and output is $PAUSE$

\begin{table}[H]
    \centering
    \caption{State Table FSM}
    \label{State Table FSM}
    \begin{tabular}{|c|c|c|c|c|c|c|}
        \hline
        $P_{0}$ & $P_{1}$ & RESET & RUN & $N_{0}$ & $N_{1}$ & PAUSE \\
        \hline
        x    & x    & 1     & x   & 1    & 1    & 1     \\
        0    & 0    & 0     & 0   & 0    & 0    & 0     \\
        0    & 0    & 0     & 1   & 1    & 0    & 0     \\
        1    & 0    & 0     & 0   & 1    & 0    & 0     \\
        1    & 0    & 0     & 1   & 0    & 1    & 0     \\
        0    & 1    & 0     & 0   & 0    & 1    & 0     \\
        0    & 1    & 0     & 1   & 1    & 1    & 0     \\
        1    & 1    & 0     & 0   & 1    & 1    & 1     \\
        1    & 1    & 0     & 1   & 0    & 0    & 1     \\
        \hline
        
    \end{tabular}
    \end{table}

There are four states, therefor we need two flip flops, since we already have implemented d-flip flop with asychron reset, except we are not using the reset input and get a similiar circuit as the the asychron reset, see figure\dots

figure av register

From the Table \ref{State Table FSM} we can find the \textbf{boolean expresion for each flip flop inputs}, wich are \emph{Next States} values, $N_{0}$ and $N_{1}$. 

\begin{equation}
    \begin{aligned}
    N_{0}&= \overline{P_{1}} \, \overline{P_{0}} \, \text{RUN} \, \overline{\text{RESET}} + \overline{P_{1}} \, P_{0} \, \overline{\text{RUN}} \, \overline{\text{RESET}} + P_{1} \, \overline{P_{0}} \, \text{RUN} \, \overline{\text{RESET}} + P_{1} \, P_{0} \, \overline{\text{RUN}} \, \overline{\text{RESET}} + \text{RESET}\\
    \Rightarrow&P_{0}\oplus RUN+ RESET\\
    N_{1}&= \overline{P_{1}} P_{0} \text{RUN} \overline{\text{RESET}} + P_{1} \overline{P_{0}} \overline{\text{RUN}} \overline{\text{RESET}} + P_{1} \overline{P_{0}} \text{RUN} \overline{\text{RESET}} + P_{1} P_{0} \overline{\text{RUN}} \overline{\text{RESET}+ RESET}\\
    \Rightarrow&\overline{P_{1}} P_{0} \text{RUN} + P_{1}(\overline{P_{0}} + \overline{\text{RUN}}) + \text{RESET}\\
    \text{PAUSE}&= P_{1} P_{0} \overline{\text{RUN}} \, \overline{\text{RESET}} + P_{1} P_{0} \text{RUN} \, \overline{\text{RESET}} + \text{RESET}
    \Rightarrow&P_{1} P_{0}+\text{RESET}\\
    \end{aligned}
\end{equation}

    


        
    
    

